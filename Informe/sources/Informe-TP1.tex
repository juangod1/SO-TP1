\documentclass[10pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{fancyhdr}
\usepackage{color}
\usepackage{graphicx}
\usepackage{listings}
\graphicspath{ {../images/} }

\definecolor{darkcerulean}{rgb}{0.03, 0.27, 0.49}

\title{
	\bf\color{darkcerulean} Trabajo Práctico 1 \\
	\color{black}Sistemas Operativos (72.11) \\
	\includegraphics{itba-escudo2}
	}
\author{Juan Godfrid - 56609 \\Pablo Radnic - 57013 \\ Joaquín Ormachea - \\Francisco Delgado -}
\pagestyle{fancy}
\fancyhf{}
\lhead{ Instituto Tecnológico de Buenos Aires - 2018}

\fancyfoot[C]{\thepage}

\fancypagestyle{plain}{
	\fancyhf{}
	\fancyfoot[C]{\thepage}
	\renewcommand{\headrulewidth}{0.4pt}
	\renewcommand{\footrulewidth}{0.4pt}
	\lhead{ Instituto Tecnológico de Buenos Aires - 2018}
}

\begin{document}
\maketitle

\newpage
\tableofcontents
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Diseño}
\section{Diseño del Sistema}
El programa fue diseñado para linux
\section{IPCs}
\subsection{Message Queue}
	El sistema utiliza dos \textit{message queues} del tipo POSIX (son más modernas que sus contrapartes SYSTEM V) en la intercomunicación de los procesos maestro y esclavo. El primero se utiliza para enviar los archivos que se requieren \textit{hashear} hacia los esclavos, mientras que el segundo se utiliza para enviar los \textit{hashes} ya procesados devuelta al proceso maestro. La utilidad de dicho IPC es una multicausalidad. Al ser una cola, el \textit{message queue} asegura el comportamiento FIFO, por lo que es ideal para enviar los \textit{hashes} de vuelta al proceso maestro, ya que asegura que el orden de llegada corresponde al orden de procesamiento. El \textit{message queue} también resulta adecuado para enviar los nombres de los archivos a los esclavos ya que los mensajes sirven como instrucciones atómicas: Los esclavos leen las instrucciones de la cola, cuando terminan, leen otra instrucción, y cuando está vacía la cola significa que el procesamiento concluyó. Todo esto se realiza sin gastar un solo ciclo de procesador del proceso maestro.
\subsection{Semáforos} 
Con respecto a los métodos de intercomunicación de procesos para respetar sus “turnos” de actividad sobre la memoria compartida, optamos por dejar 3 bytes delante del buffer denominados Safety Code, Visual Semaphore y Status Semaphore, respectivamente. 
Safety Code tiene un valor determinado por el proceso maestro, esto nos permite verificar que la aplicacion vista no conecte a un espacio de memoria compartida incorrecto desde el comienzo de su ejecucion. 
Visual Semaphore es un semáforo que informa si el proceso vista está corriendo, es iniciado por defecto en 0 y cuando se conecta la aplicación, se cambia a 1. Para finalizar de forma correcta ambas aplicaciones, el proceso maestro desconecta a la aplicación vista poniendo en 0 este semáforo.
Por último, Status Semaphore es un indicador del turno de cada proceso, 0 para el proceso maestro y 1 para el proceso vista. A partir de esto, los procesos maestro y vista evitan colisiones entre ellas. 

Para evitar el \textit{busy waiting} utilizamos la librería de semáforos de POSIX. Decidimos hacer un híbrido entre los bytes reservados y los semaphores del API de POSIX. Guardamos los valores dentro de los bytes reservados y utilizamos los semáforos POSIX para bloquear o liberar los procesos cuando necesitan manejar una espera. Este híbrido fue implementado debido a problemas encontrados en la API de POSIX de semáforos. \textit{Léase: Sección 3.1.1}.
\subsection{Memoria Compartida}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Utilización}
\section{Compilación y Ejecución}
El sistema posee un archivo de tipo \textit{GNU make} que discrimina en la compilación del código fuente en base a qué proceso debería pertenecer, de este modo logra compilar separadamente los archivos binarios de manera autónoma. El programa debe recibir como argumento por línea de comandos una lista de archivos a procesar, también puede recibir una expresión \textit{bash} para los archivos (por ejemplo: ./*.c). Un ejemplo de uso del programa es el siguiente:
\begin{lstlisting}
/SO-TP1$ make
/SO-TP1$ ./Binaries/run main.c
\end{lstlisting}


\section{Proceso Vista}
El \textit{make} compila también de manera separada el proceso vista, para ejecutarlo se debe enviar el siguiente comando:
\begin{lstlisting}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Problemas y Resoluciones}
\section{Proceso Maestro}
\subsection{Problema de espera activo}
msq recieve con block asi no hace espera activa sino que el SO lo despierta cuando la queue cambia de empty a nonempty
\section{Proceso Esclavo}
\subsection{\textit{Hasheo} de archivos}
Nos vimos ante la necesidad de utilizar la función de Linux md5sum para conseguir el hash de los archivos. Sin embargo este función
era únicamente accesible a través de línea de comandos de Linux y no en el entorno de biblioteca de funciones de c. Al no tener las
herramientas para crear una función propia debimos encontrar otra solución para el problema.

Luego de investigación en Internet se propuso utilizar la función popen() con parámetro cmd que ejecuta un proceso de línea de comandos
de Linux y a través de él ejecutar la función md5sum con los parámetros correspondientes. Luego la salida de la ejecución de las funciones
es traída al entorno de la aplicación con la función fgets.
\section{Proceso Vista}
ssss
\subsection{problema de espera activa}
	Con esta libreria inicialmente intentamos eliminar el uso de los bytes reservados en el buffer compartido. Para esto utilizamos la funcion sem\_getvalue, la cual nos presento problemas en su ejecucion dentro del ciclo principal del master. Siempre que la funcion era llamada dentro del ciclo, se generaba un segmentation fault. Debido a esto tuvimos que manejarnos sin ver los valores del semaphore por lo que finalmente decidimos hacer un hibrido entre los bytes reservados y los semaphores del API asi evitando la espera activa mediante la utilizacion de los semaforos de la api y utilizando los valores de los semaforos en el buffer de memoria compartida.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Testing}
\section{Unit testing}
Se decidio implementar unit tests para cubrir toda funcionalidad implementada por el TP que sea, por lo menos, mas de una mascara o algun agregado simlpe de una funcion de libreria standard o POSIX. 
Esto se debe a que las estructuras de POSIX, tal como el sistema de queues y el sistema de semaforos que se proveen, resultan redundantes para testear debido a que estas funciones son de uso general y ya estan testeadas por fuera de nuestro trabajo practico. Por eso consideramos que todos los tests que meramente se resumian en un test de una funcion de POSIX no eran necesarios.

\section{Fugas de Memoria}
Era posible la presencia de fugas de memoria en cualquiera de los tres procesos, las fugas de memoria
son errores de software que ocurren cuando los bloques de memoria reservados no son liberados antes de la finalización del programa.
Para asegurar la ausencia de fugas de memoria se tomo el recaudo de utilizar la herramienta \textit{Valgrind}. A continuación se encuentran
los registros del programa para distintos parámetros.
\\\\ Registros de Valgrind:
\begin{lstlisting}
>>valgrind ./Binaries/run ./*

==7295==
==7295== HEAP SUMMARY:
==7295==     in use at exit: 0 bytes in 0 blocks
==7295==   total heap usage: 11 allocs, 11 frees, 17,528 bytes allocated
==7295==
==7295== All heap blocks were freed -- no leaks are possible
==7295==
==7295== For counts of detected and suppressed errors, rerun with: -v
==7295== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)


>>valgrind ./Binaries/view 1234

==7550==
==7550== HEAP SUMMARY:
==7550==     in use at exit: 0 bytes in 0 blocks
==7550==   total heap usage: 1 allocs, 1 frees, 1,024 bytes allocated
==7550==
==7550== All heap blocks were freed -- no leaks are possible
==7550==
==7550== For counts of detected and suppressed errors, rerun with: -v
==7550== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)


>>valgrind ./Binaries/slave a a

==8156==
==8156== HEAP SUMMARY:
==8156==     in use at exit: 0 bytes in 0 blocks
==8156==   total heap usage: 4 allocs, 4 frees, 8,704 bytes allocated
==8156==
==8156== All heap blocks were freed -- no leaks are possible
==8156==
==8156== For counts of detected and suppressed errors, rerun with: -v
==8156== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)

\end{lstlisting}
Podemos afirmar que para los casos vistos nuestros programas no presentan fugas de memoria.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Limitaciones}
\section{Limitaciones del Sistema}
max message

\section{Limitaciones de la Implementación}
un archivo no se puede llamar -t -w \\
PRIVACIDAD DE LOS IPC

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Bibliografía}
\section{Fuentes}
\begin{enumerate}
\item https://stackoverflow.com/questions/3395690/md5sum-of-file-in-linux-c
\item https://stackoverflow.com/questions/4553012/checking-if-a-file-is-a-directory-or-just-a-file
\item https://users.cs.cf.ac.uk/Dave.Marshall/C/node27.html
\end{enumerate}

\end{document}
