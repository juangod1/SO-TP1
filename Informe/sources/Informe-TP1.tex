\documentclass[10pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{fancyhdr}
\usepackage{color}
\usepackage{graphicx}
\usepackage{listings}
\graphicspath{ {../images/} }

\definecolor{darkcerulean}{rgb}{0.03, 0.27, 0.49}

\title{
	\bf\color{darkcerulean} Trabajo Práctico 1 \\
	\color{black}Sistemas Operativos (72.11) \\
	\includegraphics{itba-escudo2}
	}
\author{Juan Godfrid - 56609 \\Pablo Radnic - 57013 \\ Joaquín Ormachea - \\Francisco Delgado -}
\pagestyle{fancy}
\fancyhf{}
\lhead{ Instituto Tecnológico de Buenos Aires - 2018}

\fancyfoot[C]{\thepage}

\fancypagestyle{plain}{
	\fancyhf{}
	\fancyfoot[C]{\thepage}
	\renewcommand{\headrulewidth}{0.4pt}
	\renewcommand{\footrulewidth}{0.4pt}
	\lhead{ Instituto Tecnológico de Buenos Aires - 2018}
}

\begin{document}
\maketitle

\newpage
\tableofcontents
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Diseño}
\section{Diseño del Sistema}
dshfdshfdshfds
\section{IPCs}
\subsection{Message Queue}
	El sistema utiliza dos \textit{message queues} del tipo POSIX (son más modernas que sus contrapartes SYSTEM V) en la intercomunicación de los procesos maestro y esclavo. El primero se utiliza para enviar los archivos que se requieren \textit{hashear} hacia los esclavos, mientras que el segundo se utiliza para enviar los \textit{hashes} ya procesados devuelta al proceso maestro. La utilidad de dicho IPC es una multicausalidad. Al ser una cola, el \textit{message queue} asegura el comportamiento FIFO, por lo que es ideal para enviar los \textit{hashes} de vuelta al proceso maestro, ya que asegura que el orden de llegada corresponde al orden de procesamiento. El \textit{message queue} también resulta adecuado para enviar los nombres de los archivos a los esclavos ya que los mensajes sirven como instrucciones atómicas: Los esclavos leen las instrucciones de la cola, cuando terminan, leen otra instrucción, y cuando está vacía la cola significa que el procesamiento concluyó. Todo esto se realiza sin gastar un solo ciclo de procesador del proceso maestro.
\subsection{Señales} 
Con respecto a los metodos de intercomunicacion de procesos para respetar sus “turnos” de actividad sobre la memoria compartida, optamos por dejar 3 bytes delante del buffer compartido designados para Safety code, Visual semaphore y Status semaphore, respectivamente. 
Safety code es un char con valor determinado por el master, esto nos permite verificar que la aplicacion view no logro conectarse a un espacio de memoria compartida incorrecto desde el comienzo de su ejecucion. 
El segundo es un semaforo que informa si el proceso view esta corriendo, es iniciado por defecto en 0 y luego cuando se conecta la view, se cambia a 1. Para finalizar de forma correcta ambas aplicaciones, el master vuelve a desconectar a la view poniendo en 0 este semaforo.
El tercer byte es otro semaforo que informa el turno de cada proceso. A partir de esto, los procesos view y master pueden evitar pisarse el uno al otro. 

Para evitar el uso de “busy waiting” decidimos utilizar la libreria de semaphores de postix. Decidimos hacer un hibrido entre los bytes reservados y los semaphores del API posix. Guardamos los valores dentro de los bytes reservados pero utilizabamos los semaphores para blockear o liberar los procesos cuando necesitaban manejar una espera. Se utilizaron en total 2 semaphores.
Este hibrido fue implementado debido a problemas encontrados con la API posix de semaphores, para ver mas por favor remitirse al capitulo 3 \emph{problemas y soluciones} bajo la seccion \emph{Proceso Vista} subseccion \emph{problema de espera activa}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Utilización}
\section{Compilación y Ejecución}
El sistema posee un archivo de tipo \textit{GNU make} que discrimina en la compilación del código fuente en base a qué proceso debería pertenecer, de este modo logra compilar separadamente los archivos binarios de manera autónoma. El programa debe recibir como argumento por línea de comandos una lista de archivos a procesar, también puede recibir una expresión \textit{bash} para los archivos (por ejemplo: ./*.c). Un ejemplo de uso del programa es el siguiente:
\begin{lstlisting}
/SO-TP1$ make
/SO-TP1$ ./Binaries/run main.c
\end{lstlisting}


\section{Proceso Vista}
El \textit{make} compila también de manera separada el proceso vista, para ejecutarlo se debe enviar el siguiente comando:
\begin{lstlisting}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Problemas y Resoluciones}
\section{Proceso Maestro}
\subsection{Problema de espera activo}
msq recieve con block asi no hace espera activa sino que el SO lo despierta cuando la queue cambia de empty a nonempty
\section{Proceso Esclavo}
\subsection{\textit{Hasheo} de archivos}
Nos vimos ante la necesidad de utilizar la función de Linux md5sum para conseguir el hash de los archivos. Sin embargo este función
era únicamente accesible a través de línea de comandos de Linux y no en el entorno de biblioteca de funciones de c. Al no tener las
herramientas para crear una función propia debimos encontrar otra solución para el problema.

Luego de investigación en Internet se propuso utilizar la función popen() con parámetro cmd que ejecuta un proceso de línea de comandos
de Linux y a través de él ejecutar la función md5sum con los parámetros correspondientes. Luego la salida de la ejecución de las funciones
es traída al entorno de la aplicación con la función fgets.
\section{Proceso Vista}
ssss
\subsection{problema de espera activa}
\emph{WIP}

	Con esta libreria inicialmente intentamos eliminar el uso de los bytes reservados en el buffer compartido. Para esto utilizamos la funcion sem\_getvalue, la cual nos presento problemas en su ejecucion dentro del ciclo principal del master.  Siempre que la funcion era llamada dentro del ciclo, se generaba un segmentation fault. Debido a esto tuvimos que manejarnos sin ver los valores del semaphore por lo que finalmente decidimos hacer un hibrido entre los bytes reservados y los semaphores del API.
asdfadsf
Dummy text

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Testing}
\section{Sistema de Testing}
El trabajo practico cuenta con una suite de unit test para garantizar un cierto nivel de robustes.
\subsection{Filosofia de testeo}
Se decidio implementar unit tests para cubrir toda funcionalidad implementada por el TP que sea, por lo menos, mas de una mascara o algun agregado simlpe de una funcion de libreria standard o POSIX. 
Esto se debe a que las estructuras de POSIX, tal como el sistema de queues y el sistema de semaforos que se proveen, resultan redundantes para testear debido a que estas funciones son de uso general y ya estan testeadas por fuera de nuestro trabajo practico. Por eso consideramos que todos los tests que meramente se resumian en un test de una funcion de POSIX no eran necesarios.

\section{Fugas de Memoria}
Era posible la presencia de fugas de memoria en cualquiera de los tres procesos, las fugas de memoria
son errores de software que ocurren cuando los bloques de memoria reservados no son liberados antes de la finalización del programa.
Para asegurar la ausencia de fugas de memoria se tomo el recaudo de utilizar la herramienta \textit{Valgrind}. A continuación se encuentran
los registros del programa para distintos parámetros.
\\\\ Registros de Valgrind:
\begin{lstlisting}
>>valgrind ./Binaries/run ./*

==7295==
==7295== HEAP SUMMARY:
==7295==     in use at exit: 0 bytes in 0 blocks
==7295==   total heap usage: 11 allocs, 11 frees, 17,528 bytes allocated
==7295==
==7295== All heap blocks were freed -- no leaks are possible
==7295==
==7295== For counts of detected and suppressed errors, rerun with: -v
==7295== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)


>>valgrind ./Binaries/view 1234

==7550==
==7550== HEAP SUMMARY:
==7550==     in use at exit: 0 bytes in 0 blocks
==7550==   total heap usage: 1 allocs, 1 frees, 1,024 bytes allocated
==7550==
==7550== All heap blocks were freed -- no leaks are possible
==7550==
==7550== For counts of detected and suppressed errors, rerun with: -v
==7550== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)


>>valgrind ./Binaries/slave a a

==8156==
==8156== HEAP SUMMARY:
==8156==     in use at exit: 0 bytes in 0 blocks
==8156==   total heap usage: 4 allocs, 4 frees, 8,704 bytes allocated
==8156==
==8156== All heap blocks were freed -- no leaks are possible
==8156==
==8156== For counts of detected and suppressed errors, rerun with: -v
==8156== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)

\end{lstlisting}
Podemos afirmar que para los casos vistos nuestros programas no presentan fugas de memoria.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Limitaciones}
\section{Limitaciones del Sistema}
asdfasldjfasd

\section{Limitaciones de la Implementación}
asdfasdf
Dummy text

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Bibliografía}
\section{Fuentes}
\begin{enumerate}
\item https://stackoverflow.com/questions/3395690/md5sum-of-file-in-linux-c
\item https://stackoverflow.com/questions/4553012/checking-if-a-file-is-a-directory-or-just-a-file
\item https://users.cs.cf.ac.uk/Dave.Marshall/C/node27.html
\end{enumerate}

\end{document}
